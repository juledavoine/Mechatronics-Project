/*
 * Stepper.c
 *
 * Created: 2/26/2025 6:44:15 PM
 * Author : Matthew Houston
 */ 

#include <avr/io.h>
#include <util/delay.h>

#define TRIG PB0
#define ECHO PB1
#define LED PB2

#define FREQ_CLK 8000000

// Motor Functions
void wait(volatile int number_of_msec);
void open();
void close();
void motion3();

//Ultrasonic Sensor Functions
void init_ultrasonic() {
	DDRB |= (1 << TRIG);  // Set TRIG as output
	DDRB &= ~(1 << ECHO); // Set ECHO as input
	DDRB |= (1 << LED);   // Set LED as output
}

uint16_t measure_distance() {
	uint16_t duration, distance;
	
	// Send trigger pulse
	PORTB &= ~(1 << TRIG);
	_delay_us(2);
	PORTB |= (1 << TRIG);
	_delay_us(10);
	PORTB &= ~(1 << TRIG);
	
	// Measure echo pulse width
	while (!(PINB & (1 << ECHO))); // Wait for ECHO to go HIGH
	TCNT1 = 0;
	TCCR1B |= (1 << CS11); // Start Timer1 with prescaler 8
	while (PINB & (1 << ECHO)); // Wait for ECHO to go LOW
	TCCR1B = 0; // Stop Timer1
	
	duration = TCNT1;
	distance = (duration / 2) / 58; // Convert to cm
	
	if (distance >= 200 || distance == 50) {
		return 0xFFFF; // Out of range
	}
	return distance;
}

//MAIN START

int main(void)
{
   //Set PB0 and PB1 to output pins and set them high so the LEDS start in the off position
   DDRB = 0b00000011;
   PORTB = 0b00000011;
   
   //Set PC0 to input for switch and PD4-PD7 to outputs for the H-Bridge
   DDRD = 0b11110000;
   
   //Set PC0 to input for switch
   DDRC = 0b00000000;
      
    while (1) 
    {
		while (PINC & 0b00000001) //Permanent loop to run until button is pressed
		{
						
		}
		open();
		wait(2000);
		close();
		wait(2000);
    }
}

void wait(volatile int number_of_msec) //wait function from GitHub
{
	// This subroutine creates a delay equal to number_of_msec*T, where T is 1 msec
	// It changes depending on the frequency defined by FREQ_CLK
	char register_B_setting;
	char count_limit;
	
	// Some typical clock frequencies:
	switch(FREQ_CLK) {
		case 16000000:
		register_B_setting = 0b00000011; // this will start the timer in Normal mode with prescaler of 64 (CS02 = 0, CS01 = CS00 = 1).
		count_limit = 250; // For prescaler of 64, a count of 250 will require 1 msec
		break;
		case 8000000:
		register_B_setting =  0b00000011; // this will start the timer in Normal mode with prescaler of 64 (CS02 = 0, CS01 = CS00 = 1).
		count_limit = 125; // for prescaler of 64, a count of 125 will require 1 msec
		break;
		case 1000000:
		register_B_setting = 0b00000010; // this will start the timer in Normal mode with prescaler of 8 (CS02 = 0, CS01 = 1, CS00 = 0).
		count_limit = 125; // for prescaler of 8, a count of 125 will require 1 msec
		break;
	}
	
	while (number_of_msec > 0) {
		TCCR0A = 0x00; // clears WGM00 and WGM01 (bits 0 and 1) to ensure Timer/Counter is in normal mode.
		TCNT0 = 0;  // preload value for testing on count = 250
		TCCR0B =  register_B_setting;  // Start TIMER0 with the settings defined above
		while (TCNT0 < count_limit); // exits when count = the required limit for a 1 msec delay
		TCCR0B = 0x00; // Stop TIMER0
		number_of_msec--;
	}
} // end wait()

void close()
{
	
	int steps = 11; // steps = degree of rotations / 1.8 * 4
	PORTB = 0b00000001;
	for (int i = 0; i < steps; i++)
	{
		PORTD = 0b00010000;
		wait(10);
		PORTD = 0b01000000;
		wait(10);
		PORTD = 0b00100000;
		wait(10);
		PORTD = 0b10000000;
		wait(10);
	}
	PORTB = 0b00000011;
	PORTD = 0b00000000;
}

void open()
{
	int steps = 11;
	PORTB = 0b00000010;
	for (int i = 0; i < steps; i++)
	{
		PORTD = 0b10000000;
		wait(10);
		PORTD = 0b00100000;
		wait(10);
		PORTD = 0b01000000;
		wait(10);
		PORTD = 0b00010000;
		wait(10);
	}
	PORTB = 0b00000011;
	PORTD = 0b00000000;
}

